# planner_agent.py
import datetime
import traceback
from typing import Dict, Any, List

from .research_plan_agent import ResearchAgent
from .research_data_extraction_agent import DataExtractionAgent
from .research_financial_analysis_agent import FinancialAnalysisAgent
from .business_plan_writer_agent import BusinessPlanWriterAgent

from models import SaaSIdea, BusinessPlan, FinancialMetrics, SearchResultQuality, RiskLevel
from base_agent import BaseAgent
from utils import safe_string_to_dict

class PlannerAgent(BaseAgent):
    """
    Orkestratör Agent - Tüm diğer agent'ları koordine eder ve nihai BusinessPlan üretir.
    """

    def __init__(self, web_search_engine=None):
        super().__init__()
        self.research_agent = ResearchAgent(web_search_engine)
        self.data_extraction_agent = DataExtractionAgent()
        self.financial_analysis_agent = FinancialAnalysisAgent()
        self.business_plan_writer_agent = BusinessPlanWriterAgent()
        self.orchestration_stats = {
            'plans_orchestrated': 0, 'successful_completions': 0,
            'partial_failures': 0, 'total_failures': 0, 'average_processing_time': 0.0
        }

    async def generate_business_plan(self, idea: SaaSIdea) -> BusinessPlan:
        """Ana iş planı oluşturma fonksiyonu - tüm agent'ları adım adım koordine eder."""
        start_time = datetime.datetime.now()
        print(f"🎯 [Orchestrator] Starting business plan generation for: {idea.title}")
        print("=" * 80)
        
        try:
            self.orchestration_stats['plans_orchestrated'] += 1
            
            print("\n📋 PHASE 1: RESEARCH & DATA COLLECTION")
            research_results = await self.research_agent.research_financial_metrics(idea.title, idea.trends or [])
            
            print("\n🔍 PHASE 2: DATA EXTRACTION")
            extracted_metrics = self.data_extraction_agent.extract_multiple_metrics(
                research_results, 
                self._generate_extraction_keywords(idea),
                {'market_size': 250_000_000, 'acv': 8000, 'cac': 2500, 'churn': 10}
            )
            
            print("\n📊 PHASE 3: FINANCIAL ANALYSIS")
            competitor_count = len(idea.competitors) if idea.competitors else 0
            financial_analysis = self.financial_analysis_agent.analyze_financial_metrics(
                extracted_metrics,
                competitor_count=competitor_count
            )
            
            print("\n✍️ PHASE 4: CONTENT GENERATION")
            base_content = await self.business_plan_writer_agent.generate_business_plan_content(idea, financial_analysis)
            plan_content = self.business_plan_writer_agent.validate_and_enhance_content(base_content, idea, financial_analysis)
            
            print("\n🔧 PHASE 5: BUSINESS PLAN ASSEMBLY")
            business_plan = self._assemble_final_business_plan(idea, financial_analysis, plan_content)
            
            self._update_orchestration_stats((datetime.datetime.now() - start_time).total_seconds(), success=True)
            print(f"\n✅ [Orchestrator] Business plan generated successfully in {(datetime.datetime.now() - start_time).total_seconds():.1f}s")
            return business_plan
            
        except Exception as e:
            print("\n" + "="*40)
            print("🚨 BİRİNCİL İŞLEM BAŞARISIZ! Aşağıdaki hata asıl kök nedendir:")
            print("="*40)
            traceback.print_exc()
            print("="*40 + "\n")
            
            self._update_orchestration_stats((datetime.datetime.now() - start_time).total_seconds(), success=False)
            print(f"❌ [Orchestrator] Orkestrasyon sırasında kritik hata: {e.__class__.__name__}: {e}")
            
            return self._create_emergency_fallback_plan(idea)

# In planner_agent.py, replace the whole function with this one.

    def _assemble_final_business_plan(
        self, idea: SaaSIdea, financial_analysis: Dict[str, Any], plan_content: Dict[str, Any]
    ) -> BusinessPlan:
        """
        FIXED: This function now correctly processes data types, adds all required fields,
        and removes forbidden fields to prevent Pydantic validation errors.
        """
        print("🔧 [Assembly] Assembling final plan with strict data type validation...")

        # Start with the content generated by the writer agent
        final_plan_data = {**plan_content}

        # --- FIX FOR TYPE MISMATCHES (string vs list/dict) ---
        dict_fields = ['coreFeatures', 'researchInsights', 'painPointsAddressed', 'riskAnalysis']
        for key in dict_fields:
            value = final_plan_data.get(key)
            if isinstance(value, str):
                final_plan_data[key] = safe_string_to_dict(value)
            elif value is None:
                final_plan_data[key] = {} # Ensure field exists as a dict

        # --- FIX FOR EXTRA/FORBIDDEN FIELDS ---
        # The model expects 'competitiveData' and 'competitiveScores', not 'competitiveAnalysis'.
        # We extract the data from 'competitiveAnalysis' and then remove it.
        competitive_analysis_data = final_plan_data.pop('competitiveAnalysis', {})

        # --- FIX FOR MISSING REQUIRED FIELDS ---
        metrics = financial_analysis.get('financial_metrics', {})
        revenue = financial_analysis.get('revenue_projections', {})
        health = financial_analysis.get('health_score', {})
        visualization_data = financial_analysis.get('visualization_data', {})
        
        # Add all required fields to the final data dictionary
        final_plan_data.update({
            'marketSize': metrics.get('market_size', 100000000),
            'targetRevenue': revenue.get('year_3_target', 1000000),
            'competitorCount': len(idea.competitors) if idea.competitors else 0,
            'riskLevel': financial_analysis.get('market_analysis', {}).get('risk_level', RiskLevel.HIGH),
            'confidenceScore': int(health.get('confidence_level', 50)),
            'lastUpdated': datetime.datetime.now().isoformat(),
            
            # Add the visualization data that was previously missing
            'marketData': visualization_data.get('market_data', {}),
            'revenueData': visualization_data.get('revenue_data', {}),
            'competitiveData': competitive_analysis_data,
            'competitiveScores': competitive_analysis_data.get('scores', {})
        })
        
        # Ensure mvpRoadmap is a list of strings
        if 'mvpRoadmap' in final_plan_data and isinstance(final_plan_data['mvpRoadmap'], list):
            final_plan_data['mvpRoadmap'] = [str(item) for item in final_plan_data['mvpRoadmap']]
        else:
            # Provide a default if it's missing or not a list
            final_plan_data['mvpRoadmap'] = ["Phase 1: Discovery & Planning", "Phase 2: MVP Development", "Phase 3: Beta & Launch"]


        print("✅ [Assembly] Final data dictionary prepared for validation.")
        return BusinessPlan(**final_plan_data)


    def _generate_extraction_keywords(self, idea: SaaSIdea) -> Dict[str, List[str]]:
        main_topic = idea.trends[0] if idea.trends else idea.title.split()[0]
        return {
            'market_size': [f"{main_topic} market size", "total addressable market"],
            'acv': ["annual contract value", "average contract value", "ACV"],
            'cac': ["customer acquisition cost", "CAC", "cost to acquire customer"],
            'churn': ["churn rate", "customer churn", "retention rate"]
        }

    def _create_emergency_fallback_plan(self, idea: SaaSIdea) -> BusinessPlan:
        """FIXED: Pydantic validasyonunu geçecek şekilde tüm alanlar genişletildi ve tamamlandı."""
        print("🚨 [Orchestrator] Creating robust emergency fallback business plan...")
        now = datetime.datetime.now().isoformat()
        fm_obj = FinancialMetrics(market_size=100000000, acv=5000, cac=2500, churn_rate=0.15)
        sq_obj = SearchResultQuality(queries_executed=0, results_found=0, values_extracted=0, fallback_used=4)
        
        # FIXED: Wrap string content in dictionaries to match the BusinessPlan model
        emergency_data = {
            'targetAudience': {'description': f"This emergency plan targets mid-sized technology companies (200-1000 employees) that are struggling with productivity and workflow automation issues and are actively looking for robust, scalable solutions like '{idea.title}'."},
            'coreFeatures': f"The core features of the '{idea.title}' solution are specifically designed to tackle primary pain points such as '{', '.join(idea.painPoints)}'. This includes an advanced AI-driven automation engine, a real-time collaborative analytics dashboard, and seamless integration with third-party enterprise software.",
            'monetizationModel': {'description': "A tiered, subscription-based SaaS pricing model is proposed. Tiers will include 'Starter' for small teams, 'Professional' for growing businesses with more advanced needs, and an 'Enterprise' plan with dedicated support and custom integrations."},
            'marketingStrategy': {'description': "Our go-to-market strategy will focus heavily on digital channels, including in-depth content marketing (blogs, whitepapers), targeted SEO for relevant industry keywords, and paid social media campaigns on LinkedIn to reach key IT and operations decision-makers."},
            'competitiveAdvantage': {'description': f"Our primary competitive advantage is the platform's superior, intuitive user experience and the innovative application of proprietary AI technology to solve complex problems more effectively than {idea.competitors[0] if idea.competitors else 'any existing solution on the market'}."},
            'researchInsights': "Market research indicates a strong and growing demand for solutions that improve workplace productivity and integrate AI. This trend strongly supports the viability and potential high adoption rate for our product.",
            'painPointsAddressed': f"The solution directly addresses critical operational issues such as '{', '.join(idea.painPoints)}' by providing tangible, easy-to-implement tools that deliver measurable improvements in efficiency, cost reduction, and overall ROI.",
            'marketOpportunity': {'description': "The total addressable market for business process automation SaaS is estimated in the billions of dollars. By targeting a specific, underserved niche within this market, we project a significant and achievable opportunity for rapid growth."},
            'riskAnalysis': "Key risks include intense competition from established players and the general pace of market adoption. These will be mitigated through continuous innovation, building a strong customer feedback loop, and employing an agile development methodology.",
            'mvpRoadmap': ["Market research (Month 1-2)", "MVP development (Month 3-5)", "Beta testing and Launch (Month 6)"],
            'marketSize': 100_000_000, 'targetRevenue': 1_000_000, 'mvpTimeframe': 6,
            'competitorCount': len(idea.competitors) or 1, 'riskLevel': RiskLevel.HIGH,
            'confidenceScore': 40, 'dataSource': 'emergency_fallback', 'lastUpdated': now,
            'financialMetrics': fm_obj.model_dump(by_alias=True), 
            'searchQuality': sq_obj.model_dump(by_alias=True),
            'marketData': {'labels': ['TAM', 'SAM', 'SOM'], 'values': [100000000, 20000000, 1000000], 'colors': ['#8b5cf6', '#a855f7', '#c084fc']},
            'revenueData': {'labels': ['Y1', 'Y2', 'Y3'], 'revenue': [150000, 500000, 1000000]},
            'competitiveData': {'labels': ['Price', 'Features', 'Quality', 'Marketing', 'Innovation'], 'yourBusiness': [70, 75, 80, 60, 85], 'competitorAvg': [75, 80, 85, 80, 70]},
            'competitiveScores': {'innovation': 60, 'quality': 65, 'pricing': 70}
        }
        return BusinessPlan(**emergency_data)

    def _update_orchestration_stats(self, processing_time: float, success: bool):
        if success:
            self.orchestration_stats['successful_completions'] += 1
        else:
            self.orchestration_stats['total_failures'] += 1